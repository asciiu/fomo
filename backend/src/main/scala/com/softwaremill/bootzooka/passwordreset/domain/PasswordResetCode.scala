package com.softwaremill.bootzooka.passwordreset.domain

import java.time.temporal.ChronoUnit
import java.time.{Instant, OffsetDateTime, ZoneOffset}
import java.util.UUID

import com.datastax.driver.core.ConsistencyLevel
import com.outworkers.phantom.builder.query.InsertQuery
import com.outworkers.phantom.dsl.{PartitionKey, Table}
import com.outworkers.phantom.dsl._
import database.dao.PasswordResetCodeDao
import models.User
import org.joda.time.DateTime

import scala.concurrent.Future

/**
  * Code used in the process of password reset.
  * By default this code has the `validTo` set to now plus 24 hours.
  */
case class PasswordResetCode(id: UUID, code: String, user: User, validTo: DateTime)


abstract class PasswordResetCodes extends Table[PasswordResetCodes, PasswordResetCode] {

  object code extends StringColumn with PartitionKey
  object id extends UUIDColumn
  object user_id extends UUIDColumn
  object valid_to extends DateTimeColumn

  def add(code: PasswordResetCode): Future[ResultSet] = {
    store(code)
      .consistencyLevel_=(ConsistencyLevel.ALL)
      .future()
  }

  /**
    * Note: this was supposed to be generated by Phantom!
    *
    * @param record
    * @return
    */
  def store(record: PasswordResetCode): InsertQuery.Default[PasswordResetCodes, PasswordResetCode] = {
    insert
      .value(_.id, record.id)
      .value(_.code, record.code)
      .value(_.user_id, record.user.id)
      .value(_.valid_to, record.validTo)
  }


  def findByCode(code: String): Future[Option[PasswordResetCode]] = {
    select.where(_.code eqs code).one()
  }

  def remove(code: String): Future[ResultSet] = {
    delete.where(_.code eqs code)
      .consistencyLevel_=(ConsistencyLevel.ALL)
      .future()
  }
}

object PasswordResetCode {
  def apply(code: String, user: User): PasswordResetCode = {
    //val nextDay = Instant.now().plus(24, ChronoUnit.HOURS).atOffset(ZoneOffset.UTC)
    val nextDay = DateTime.now().plusDays(1)
    PasswordResetCode(UUID.randomUUID(), code, user, nextDay)
  }
}
